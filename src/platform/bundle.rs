pub use uuid::Uuid;
use {
	super::*,
	alloy::primitives::{B256, Keccak256, TxHash},
	core::fmt::Debug,
	reth::{ethereum::primitives::SignedTransaction, primitives::Recovered},
	reth_evm::revm::state::EvmState,
};

/// This trait defines a set of transactions that are bundled together and
/// should be processed as a single unit of execution.
///
/// Examples of bundles are objects sent through the `eth_sendBundle` RPC
/// method.
pub trait Bundle<P: Platform>: Clone + Debug + Send + Sync + 'static {
	/// Returns an iterator over the transactions in the bundle.
	fn transactions(&self) -> &[Recovered<types::Transaction<P>>];

	/// Returns a new bundle with the exact configuration and metadata as this one
	/// but without the transaction with the given hash. The returned bundle must
	/// maintain the same order of transactions as the original bundle.
	///
	/// The system guarantees that this function will not be called for a
	/// transaction that is not in the bundle, or a transaction that is not
	/// optional or the last remaining transaction in the bundle.
	fn without_transaction(self, tx: TxHash) -> Self;

	/// Statically checks if the bundle is eligible for inclusion in the block
	/// before executing any of its transactions.
	fn is_eligible(&self, block: &BlockContext<P>) -> Eligibility;

	/// Checks if a transaction with a given hash is allowed to not have a
	/// successful execution result for this bundle.
	///
	/// the `tx` is the hash of the transaction to check and it is guaranteed to
	/// be hash of one of the transactions returned by `transactions()`.
	fn is_allowed_to_fail(&self, tx: TxHash) -> bool;

	/// Checks if a transaction with the given hash may be removed from the
	/// bundle without affecting its validity.
	fn is_optional(&self, tx: TxHash) -> bool;

	/// An optional check for bundle implementations that have validity
	/// requirements on the resulting state. For example there may be an
	/// implementation that requires a certain minimal balance in some account
	/// after the bundle is executed. The state that is passed in this method
	/// contains only entries that were modified or created by executing
	/// transactions from this bundle.
	fn is_new_state_valid(&self, _: &EvmState) -> bool {
		true
	}

	/// Calculates the hash of the bundle based on its transactions.
	/// This is depricated and used only for backwards compatibility use uuid
	/// instead. This hash is not unique across bundles with the same set of
	/// transactions but different metadata.
	fn hash(&self) -> B256 {
		let mut hasher = Keccak256::default();
		for tx in self.transactions() {
			hasher.update(tx.tx_hash());
		}
		hasher.finalize()
	}

	/// A unique identifier for the bundle and its metadata.
	/// This is most often generated by the RPC interface when a bundle is
	/// received from a client.
	fn uuid(&self) -> Uuid;
}

/// The eligibility of a bundle for inclusion in a block.
#[derive(Debug, Clone)]
pub enum Eligibility {
	/// The bundle is eligible for inclusion in this given block. This does not
	/// mean that the bundle will actually be included, but only that static
	/// checks that do not require execution checks have passed.
	///
	/// Bundles in this state if not included in the block should be kept in the
	/// pool and retried in future blocks.
	Eligible,

	/// The bundle is not eligible for inclusion in the given block but may
	/// become eligible in the future. An example of this state is when the
	/// bundle has not reached yet the minimum required block number for
	/// inclusion.
	///
	/// Bundles in this state should be kept in the pool and retried in future
	/// blocks.
	TemporarilyIneligible,

	/// The bundle is permanently not eligible for inclusion in this or any
	/// future block. An example of this state is when the current block number
	/// is past the maximum block number of the bundle if the bundle
	/// implementation supports this type of limit.
	///
	/// Bundles in this state should be removed from the pool and not attempted
	/// to be included in any future blocks.
	PermanentlyIneligible,
}

/// This is a quality of life helper that allows users of this api to say:
/// `if bundle.is_eligible(block) { .. }`, without going into the details of
/// the ineligibility.
impl PartialEq<bool> for Eligibility {
	fn eq(&self, other: &bool) -> bool {
		match self {
			Eligibility::Eligible => *other,
			Eligibility::TemporarilyIneligible
			| Eligibility::PermanentlyIneligible => !(*other),
		}
	}
}

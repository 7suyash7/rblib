use {
	super::*,
	crate::alloy,
	alloy::eips::eip7840::BlobParams,
	core::{num::NonZero, time::Duration},
};

/// Types implementing this trait are responsible for calculating
/// pipeline-scope-level payload limits. They always receive the limits
/// generated by enclosing pipelines. When types implementing this trait are
/// used on the top-level pipeline, then the `enclosing` limits are the ones
/// generated by the `PlatformLimits` implementation for the platform `P`.
///
/// Implementations of this type are called every time their scope is entered.
pub trait ScopedLimits<P: Platform>: Send + Sync + 'static {
	/// Creates new limits for its pipeline scope.
	///
	/// As an input this method receives the current payload checkpoint and the
	/// limits imposed by its parent scope (or limits created by
	/// `PlatformLimits`).
	fn create(&self, payload: &Checkpoint<P>, enclosing: &Limits) -> Limits;
}

/// Convinience trait that allows API users to either use a `ScopedLimits` type
/// or a concrete limits value in [`Pipeline::with_limits`].
pub trait IntoScopedLimits<P: Platform, Marker = ()> {
	/// Convert the type into a limits factory.
	fn into_scoped_limits(self) -> impl ScopedLimits<P>;
}

impl<T: ScopedLimits<P>, P: Platform> IntoScopedLimits<P, Variant<0>> for T {
	fn into_scoped_limits(self) -> impl ScopedLimits<P> {
		self
	}
}

impl<P: Platform> IntoScopedLimits<P, Variant<1>> for Limits {
	fn into_scoped_limits(self) -> impl ScopedLimits<P> {
		struct FixedLimits(Limits);
		impl<P: Platform> ScopedLimits<P> for FixedLimits {
			fn create(&self, _: &Checkpoint<P>, _: &Limits) -> Limits {
				self.0
			}
		}

		FixedLimits(self)
	}
}

/// Scales down the limits of the enclosing pipeline (or platform default) by a
/// fixed factor.
#[derive(Default)]
pub struct Scaled {
	gas: Option<ScaleOp<u64>>,
	max_txs: Option<ScaleOp<usize>>,
	max_blob_count: Option<ScaleOp<u64>>,
	max_blobs_per_tx: Option<ScaleOp<u64>>,
	deadline: Option<ScaleOp<Duration>>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ScaleOp<T> {
	/// numerator, denominator
	Fraction(u32, NonZero<u32>),
	Minus(T),
	Fixed(T),
	Zero,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Fraction(pub u32, pub NonZero<u32>);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Minus<T>(pub T);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Fixed<T>(pub T);

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Zero;

impl<T> From<Fraction> for ScaleOp<T> {
	fn from(val: Fraction) -> Self {
		ScaleOp::Fraction(val.0, val.1)
	}
}

impl<T> From<Minus<T>> for ScaleOp<T> {
	fn from(val: Minus<T>) -> Self {
		ScaleOp::Minus(val.0)
	}
}

impl<T> From<Fixed<T>> for ScaleOp<T> {
	fn from(val: Fixed<T>) -> Self {
		ScaleOp::Fixed(val.0)
	}
}

impl<T> From<Zero> for ScaleOp<T> {
	fn from(_: Zero) -> Self {
		ScaleOp::Zero
	}
}

impl<P: Platform> ScopedLimits<P> for Scaled {
	fn create(&self, _: &Checkpoint<P>, enclosing: &Limits) -> Limits {
		let mut limits = *enclosing;

		if let Some(ref op) = self.gas {
			limits.gas_limit = op.apply(limits.gas_limit);
		}

		if let Some(ref op) = self.deadline {
			limits.deadline = op.apply(limits.deadline);
		}

		if let Some(ref op) = self.max_txs {
			limits.max_transactions = op.apply(limits.max_transactions);
		}

		if let Some(ref op) = self.max_blob_count {
			limits.blob_params = limits.blob_params.map(|params| BlobParams {
				max_blob_count: op.apply(params.max_blob_count),
				..params
			});
		}

		if let Some(ref op) = self.max_blobs_per_tx {
			limits.blob_params = limits.blob_params.map(|params| BlobParams {
				max_blobs_per_tx: op.apply(params.max_blobs_per_tx),
				..params
			});
		}

		limits
	}
}

impl Scaled {
	#[must_use]
	pub const fn new() -> Self {
		Self {
			gas: None,
			max_txs: None,
			max_blob_count: None,
			max_blobs_per_tx: None,
			deadline: None,
		}
	}

	pub fn from(&self, limits: &Limits) -> Limits {
		let mut limits = *limits;

		if let Some(ref op) = self.gas {
			limits.gas_limit = op.apply(limits.gas_limit);
		}

		if let Some(ref op) = self.deadline {
			limits.deadline = op.apply(limits.deadline);
		}

		if let Some(ref op) = self.max_txs {
			limits.max_transactions = op.apply(limits.max_transactions);
		}

		if let Some(ref op) = self.max_blob_count {
			limits.blob_params = limits.blob_params.map(|params| BlobParams {
				max_blob_count: op.apply(params.max_blob_count),
				..params
			});
		}

		if let Some(ref op) = self.max_blobs_per_tx {
			limits.blob_params = limits.blob_params.map(|params| BlobParams {
				max_blobs_per_tx: op.apply(params.max_blobs_per_tx),
				..params
			});
		}

		limits
	}

	#[must_use]
	pub fn deadline(self, op: impl Into<ScaleOp<Duration>>) -> Self {
		Self {
			deadline: Some(op.into()),
			..self
		}
	}

	#[must_use]
	pub fn gas(self, op: impl Into<ScaleOp<u64>>) -> Self {
		Self {
			gas: Some(op.into()),
			..self
		}
	}

	#[must_use]
	pub fn max_txs(self, op: impl Into<ScaleOp<usize>>) -> Self {
		Self {
			max_txs: Some(op.into()),
			..self
		}
	}

	#[must_use]
	pub fn max_blobs(self, op: impl Into<ScaleOp<u64>>) -> Self {
		Self {
			max_blob_count: Some(op.into()),
			..self
		}
	}

	#[must_use]
	pub fn max_blobs_per_tx(self, op: impl Into<ScaleOp<u64>>) -> Self {
		Self {
			max_blobs_per_tx: Some(op.into()),
			..self
		}
	}
}

impl ScaleOp<u64> {
	pub fn apply(&self, value: u64) -> u64 {
		match self {
			ScaleOp::Fraction(numerator, denominator) => {
				let n = u64::from(*numerator);
				let d = u64::from(denominator.get());
				value.saturating_mul(n) / d
			}
			ScaleOp::Minus(amount) => value.saturating_sub(*amount),
			ScaleOp::Fixed(amount) => *amount,
			ScaleOp::Zero => 0,
		}
	}
}

impl ScaleOp<usize> {
	pub fn apply(&self, value: Option<usize>) -> Option<usize> {
		match (self, value) {
			(ScaleOp::Fraction(numerator, denominator), Some(value)) => {
				let n = *numerator as usize;
				let d = denominator.get() as usize;
				Some(value.saturating_mul(n) / d)
			}
			(ScaleOp::Minus(amount), Some(value)) => {
				Some(value.saturating_sub(*amount))
			}
			(ScaleOp::Fixed(amount), Some(_)) => Some(*amount),
			(ScaleOp::Zero, _) => Some(0),
			(_, None) => None,
		}
	}
}

impl ScaleOp<Duration> {
	pub fn apply(&self, value: Option<Duration>) -> Option<Duration> {
		match (self, value) {
			(ScaleOp::Fraction(numerator, denominator), Some(value)) => {
				let n = *numerator;
				let d = denominator.get();
				Some(value.saturating_mul(n) / d)
			}
			(ScaleOp::Minus(amount), Some(value)) => {
				Some(value.saturating_sub(*amount))
			}
			(ScaleOp::Fixed(amount), _) => Some(*amount),
			(ScaleOp::Zero, _) => Some(Duration::ZERO),
			(_, None) => None,
		}
	}
}

#[cfg(test)]
mod tests {
	use {
		super::*,
		crate::test_utils::*,
		core::{
			num::NonZero,
			sync::atomic::{AtomicU32, Ordering},
		},
		std::sync::Arc,
	};

	assert_is_dyn_safe!(ScopedLimits<P>, P: Platform);

	#[derive(Debug)]
	struct TestStep {
		must_run: bool,
		iter: AtomicU32,
		break_after: AtomicU32,

		minimum_iterations: Option<u32>,
		maximum_iterations: Option<u32>,
		expected_gas_limit: Option<u64>,
		expected_deadline: Option<Duration>,
		sleep_on_step: Option<Duration>,
	}

	impl Default for TestStep {
		fn default() -> Self {
			Self {
				must_run: false,
				iter: AtomicU32::new(0),
				break_after: AtomicU32::new(1),
				expected_gas_limit: None,
				expected_deadline: None,
				minimum_iterations: None,
				maximum_iterations: None,
				sleep_on_step: None,
			}
		}
	}

	impl TestStep {
		#[allow(dead_code)]
		fn break_after(self, iterations: u32) -> Self {
			self.break_after.store(iterations, Ordering::Relaxed);
			self
		}

		fn expect_gas_limit(mut self, gas_limit: u64) -> Self {
			self.expected_gas_limit = Some(gas_limit);
			self
		}

		fn expect_deadline(mut self, deadline: Duration) -> Self {
			self.expected_deadline = Some(deadline);
			self
		}

		fn expect_minimum_iterations(mut self, iterations: u32) -> Self {
			self.minimum_iterations = Some(iterations);
			self
		}

		fn expect_maximum_iterations(mut self, iterations: u32) -> Self {
			self.maximum_iterations = Some(iterations);
			self
		}

		fn sleep_on_step(mut self, duration: Duration) -> Self {
			self.sleep_on_step = Some(duration);
			self
		}

		#[track_caller]
		fn must_run(mut self) -> Self {
			self.must_run = true;
			self
		}
	}

	impl Drop for TestStep {
		fn drop(&mut self) {
			assert!(
				!self.must_run || self.iter.load(Ordering::Relaxed) > 0,
				"Step was expected to run, but did not."
			);

			if let Some(minimum_iterations) = self.minimum_iterations {
				assert!(
					self.iter.load(Ordering::Relaxed) >= minimum_iterations,
					"Expected step to run at least {minimum_iterations} times, but ran \
					 {} times.",
					self.iter.load(Ordering::Relaxed)
				);
			}

			if let Some(maximum_iterations) = self.maximum_iterations {
				assert!(
					self.iter.load(Ordering::Relaxed) <= maximum_iterations,
					"Expected step to run at most {maximum_iterations} times, but ran \
					 {} times.",
					self.iter.load(Ordering::Relaxed)
				);
			}
		}
	}

	impl<P: Platform> Step<P> for TestStep {
		async fn step(
			self: Arc<Self>,
			payload: Checkpoint<P>,
			ctx: StepContext<P>,
		) -> ControlFlow<P> {
			if let Some(sleep_duration) = self.sleep_on_step {
				tokio::time::sleep(sleep_duration).await;
			}

			let break_after = self.break_after.load(Ordering::Relaxed);
			if self.iter.fetch_add(1, Ordering::Relaxed) >= break_after {
				return ControlFlow::Break(payload);
			}

			if ctx.deadline_reached() {
				return ControlFlow::Break(payload);
			}

			if let Some(expected_gas_limit) = self.expected_gas_limit {
				assert_eq!(
					ctx.limits().gas_limit,
					expected_gas_limit,
					"Expected gas limit to be {expected_gas_limit}, but got {}",
					ctx.limits().gas_limit
				);
			}

			if let Some(expected_deadline) = self.expected_deadline {
				assert_eq!(
					ctx.limits().deadline,
					Some(expected_deadline),
					"Expected deadline to be {expected_deadline:?}, but got {:?}",
					ctx.limits().deadline
				);
			}

			ControlFlow::Ok(payload)
		}
	}

	#[rblib_test(Ethereum, Optimism)]
	async fn one_level_flat<P: TestablePlatform>() -> eyre::Result<()> {
		let pipeline = Pipeline::<P>::default()
			.with_step(
				TestStep::default()
					.expect_gas_limit(1000)
					.expect_deadline(Duration::from_millis(500))
					.must_run(),
			)
			.with_limits(
				Limits::gas_limit(1000).with_deadline(Duration::from_millis(500)),
			);
		P::create_test_node(pipeline).await?.next_block().await?;
		Ok(())
	}

	#[rblib_test(Ethereum, Optimism)]
	async fn scale_fraction<P: TestablePlatform>() -> eyre::Result<()> {
		let pipeline = Pipeline::<P>::default()
			.with_pipeline(
				Once,
				(TestStep::default()
					.expect_gas_limit(500)
					.expect_deadline(Duration::from_millis(250))
					.must_run(),)
					.with_limits(
						Scaled::default()
							.gas(Fraction(1, NonZero::new(2).unwrap()))
							.deadline(Fraction(1, NonZero::new(2).unwrap())),
					),
			)
			.with_limits(
				Limits::gas_limit(1000).with_deadline(Duration::from_millis(500)),
			);
		P::create_test_node(pipeline).await?.next_block().await?;
		Ok(())
	}

	#[rblib_test(Ethereum, Optimism)]
	async fn scale_minus<P: TestablePlatform>() -> eyre::Result<()> {
		let pipeline = Pipeline::<P>::default()
			.with_pipeline(
				Once,
				(TestStep::default()
					.expect_gas_limit(900)
					.expect_deadline(Duration::from_millis(400))
					.must_run(),)
					.with_limits(
						Scaled::default()
							.gas(Minus(100))
							.deadline(Minus(Duration::from_millis(100))),
					),
			)
			.with_limits(
				Limits::gas_limit(1000).with_deadline(Duration::from_millis(500)),
			);
		P::create_test_node(pipeline).await?.next_block().await?;
		Ok(())
	}

	/// two levels of scaling
	#[rblib_test(Ethereum, Optimism)]
	async fn deadline_approaches<P: TestablePlatform>() -> eyre::Result<()> {
		let pipeline = Pipeline::<P>::default()
			.with_pipeline(
				Once,
				Pipeline::default()
					.with_pipeline(
						Once,
						(TestStep::default()
							.expect_gas_limit(400)
							.expect_deadline(Duration::from_millis(300))
							.expect_minimum_iterations(2)
							.expect_maximum_iterations(3)
							.sleep_on_step(Duration::from_millis(100))
							.must_run(),)
							.with_limits(
								Scaled::default()
									.gas(Minus(100))
									.deadline(Minus(Duration::from_millis(100))),
							),
					)
					.with_limits(
						Scaled::default()
							.gas(Fraction(1, NonZero::new(2).unwrap()))
							.deadline(Fraction(1, NonZero::new(2).unwrap())),
					),
			)
			.with_limits(
				Limits::gas_limit(1000).with_deadline(Duration::from_millis(800)),
			);
		P::create_test_node(pipeline).await?.next_block().await?;
		Ok(())
	}
}
